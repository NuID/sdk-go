package auth

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"io/ioutil"
)

// Get a credential challenge from the API, usually during login flow. The
// returned challenge can be used to generate a proof from the user's secret.
// Used in conjunction with auth.ChallengeVerify().
//
// The credential is usually retrieved by calling the auth.CredentialGet()
// method.
func (auth *AuthAPI) ChallengeGet(credential map[string]interface{}) (resp *http.Response, body *ChallengeGetResponse, err error) {
	resp, err = auth.post("/challenge", map[string]interface{}{
		"nuid/credential": credential,
	})
	if err != nil {
		return
	}
	if resp.StatusCode != 201 {
		err = errors.New(fmt.Sprintf("Could not get challenge for credential, endpoint returned %s", resp.Status))
		return
	}

	defer resp.Body.Close()
	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}
	if !bytes.Equal(bodyBytes, nil) {
		body = &ChallengeGetResponse{}
		err = json.Unmarshal(bodyBytes, body)
	}
	return
}

// Verify a credential challenge with a proof generated from the challenge
// claims and the user's secret. Generated proof from the claims contained in
// the challengeJWT and the user's secret. This proof is generated by
// `Zk.proofFromSecretAndChallenge(secret, challenge)` available in the npm
// package `@nuid/zk`.
//
// See https://www.npmjs.com/package/@nuid/zk
// See https://www.npmjs.com/package/@nuid/cli
func (auth *AuthAPI) ChallengeVerify(challengeJWT JWT, proof map[string]interface{}) (resp *http.Response, err error) {
	resp, err = auth.post("/challenge/verify", map[string]interface{}{
		"nuid.credential.challenge/jwt": challengeJWT,
		"nuid.credential/proof": proof,
	})
	if err == nil && resp.StatusCode != 200 {
		err = errors.New(fmt.Sprintf("Could not verify challenge, endpoint returned %s", resp.Status))
	}
	return
}

// Create a credential from a verified credential (meaning a credential
// generated from the user's secret), usually during user registration. The
// response body contains the new Credential and the user's unique NuID which
// should be used as a reference to the user's credential for later
// authentication attempts.
//
// The verifiedCredential is a map[string]interface{} returned by calling `Zk.verifiableFromSecret(secret)`
//
// See auth.CredentialGet(nuid)
// See https://www.npmjs.com/package/@nuid/zk
// See https://www.npmjs.com/package/@nuid/cli
func (auth *AuthAPI) CredentialCreate(verifiedCredential map[string]interface{}) (resp *http.Response, body *CredentialCreateResponse, err error) {
	resp, err = auth.post("/credential", map[string]interface{}{
		"nuid.credential/verified": verifiedCredential,
	})
	if err != nil {
		return
	}
	if resp.StatusCode != 201 {
		err = errors.New(fmt.Sprintf("Could not create credential, endpoint returned %s", resp.Status))
		return
	}

	defer resp.Body.Close()
	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}
	if !bytes.Equal(bodyBytes, nil) {
		body = &CredentialCreateResponse{}
		err = json.Unmarshal(bodyBytes, body)
	}
	return
}

// Fetch a credential by it's unique NuID which can be extracted
// from the response to auth.CredentialCreate().
//
// Generally you will end up storing the NuID with your user record during
// registration. Later during login use the NuID to fetch the credential using
// this method, passing the returned credential from the response body to
// auth.ChallengeGet().
func (auth *AuthAPI) CredentialGet(nuid string) (resp *http.Response, body *CredentialGetResponse, err error) {
	resp, err = auth.get("/credential/" + nuid)
	if err != nil {
		return
	}
	if resp.StatusCode != 200 {
		err = errors.New(fmt.Sprintf("Could not get credential with nuid %s, endpoint returned %s", nuid, resp.Status))
		return
	}

	defer resp.Body.Close()
	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil || bytes.Equal(bodyBytes, nil) {
		return
	}
	if !bytes.Equal(bodyBytes, nil) {
		body = &CredentialGetResponse{}
		err = json.Unmarshal(bodyBytes, body)
	}
	return
}
